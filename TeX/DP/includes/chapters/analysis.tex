Within this section, we will analyze the system in detail, covering its description, inputs, outputs, disturbances, and both static, dynamic characteristic, and impulse response.
For each of the aforementioned characteristics, we will provide experimental results obtained from the real system and the process of gathering the data. Thus, proposing suitable experiments for measuring the respective characteristics.
Implementing the experiments on the real system with the help of an \acrshort{mcu} and MATLAB scripts for data acquisition and processing.

With the understanding gained from this analysis, we will discuss the possibility of deriving a physical model of the system.
Based on the conclusion of this discussion, we will either proceed to develop the physical model or identify a linearized \acrshort{ss} representation of the system at a certain \acrshort{op} for further controller design.


\subsection{System Description}
The system under consideration is an actuated (propelled) pendulum consisting of a mass attached to the end of a rigid rod, which is free to swing in a vertical plane under the influence of gravity as can be seen on \figref{fig:pendulum}.
The pendulum is actuated by a propeller directly attached to the motor shaft of a separately excited direct current (\acrshort{dc}) motor, which represents the attached mass on the end of the rod.

The motor is powered by a \acrshort{dc} voltage source. Allowing for control over the pendulum's motion by controlling the pulse-width modulated (\acrshort{pwm}) signal applied to the gate of a transistor from the microcontroller.
This transistor acts as a switch, regulating the voltage supplied to the motor based on the duty cycle of the \acrshort{pwm} signal. The \acrshort{mcu} cannot directly control the voltage supplied to the motor, as it can only output digital signals (high or low voltage levels), which in logic level correspond to either $5V$ or $0V$ in our case, when using the Arduino Uno R3.

\begin{center}
    \vspace{-10pt}

    \tabcaption{Ranges and units of signals}
    \label{tab:ranges_and_units_of_signals}
    \begin{tabular*}{\textwidth}{@{ \extracolsep{\fill}} lll}
        \toprule
        Signal & Value Range & Unit \\
        \midrule
        Input & $0\%$ to $100\%$ & [\%] \\
        Output & \ang{-50} to \ang{210} & [\si{\degree}] \\
        Potentiometer & $0\%$ to $100\%$ & [\%] \\
        \bottomrule
    \end{tabular*}
\end{center}

This means that the control input to the system is the duty cycle of the \acrshort{pwm} signal, which can vary from $0\%$ to $100\%$ - $0V$ to $5V$ respectively, to open or close the transistor. The control input signal is provided by the microcontroller unit (\acrshort{mcu})'s pin \textasciitilde$D5$.
The pendulum's angular position is measured using a rotary magnetic encoder AS5600 mounted at the pivot point of the pendulum, which provides high-resolution angular position feedback within the range \ang{-50} to \ang{210}.
At last an integrated potentiometer is included in the system, which can be used for various purposes, such as early termination of a simulation when the signal value exceeds 90\%, or as a reference input for the controller. The potentiometer signal ranges from $0\%$ to $100\%$.
All the signal ranges and their respective units can be found summarized in \tabref{tab:ranges_and_units_of_signals}.

\begin{center}
    \vbox{%
        \makebox[\textwidth][c]{%
        %% TODO: change the image to the actual device being analyzed/controlled
            \includegraphics{pendulum.png}
        }

        \figcaption{
            The considered actuated pendulum system named AeroShield (\acrshort{as}) device.
        }
        \label{fig:pendulum}
    }%vbox
\end{center}

The pendulum itself has a physical angular constraint from \ang{-50} to \ang{210}, which is enforced by two physical stoppers located at these angles. We will not be considering these constraints in our modeling and controller design, as we will be operating the system within these limits.
Although we will attempt to account for these constraints during simulation. %% TODO: expand on how we will account for constraints in simulation and probably simulate the counter-effect of hitting the stoppers. (sounds like fun!) Try to simulate the effect using a very stiff spring-damper system at the limits, or the game engine way?
The propeller attached to the motor shaft generates thrust, which produces a torque around the pivot point of the pendulum, allowing us to control its angular position. This torque generated by the propeller only acts in one direction, meaning that it can only accelerate the pendulum in the positive angular direction.
Thus, to decelerate or move the pendulum in the negative angular direction, we will rely on gravitational forces and frictional forces acting on the system.

Whenever the pendulum is in negative angular position, it is either the consequence of initial conditions (e.g., starting from rest at a negative angle; manually moved to a negative angle) or due to gravitational forces pulling it downwards when the propeller is not generating enough thrust to counteract gravity.

Let us make prior assumptions about the system: if the pendulum is to be held at a \ang{90} angle, the propeller must generate the highest amount of thrust to counteract the gravitational torque acting on the pendulum. When the pendulum is above \ang{90}, the propeller must generate less thrust, as gravity will assist in holding the pendulum in place.
The process of gravity assisting the propeller in holding the pendulum in place will remain true until the pendulum reaches the angle of \ang{180}, after which gravity will start to oppose the propeller's thrust again, requiring more thrust in reverse direction to hold the pendulum in place.
This implies the system is controllable within the angular range of \ang{0} to \ang{180}.


\subsection{Communication}
Throughout the thesis, we will be utilizing serial communication \acrshort{uart} between the \acrshort{mcu} and MATLAB for data acquisition and control signal transmission.
The \acrshort{mcu} will be responsible for reading the angular position from the rotary encoder, generating the \acrshort{pwm} signal to control the motor, and sending the measured data to MATLAB for further processing and analysis.
MATLAB will handle the the more demanding tasks, such as data logging, real-time visualization, and controller computations, leveraging powerful computational capabilities on the host computer. This is especially useful during the experimental phase, where rapid prototyping and testing of different control strategies are required.
This approach limits us to timing constraints imposed by the serial communication speed and MATLAB's processing time. Therefore, we will mainly choose sampling times in the range of $20$ms to $100$ms - where \emph{ms} stands for milliseconds, see the \tabref{tab:configurations_of_data_structure} for details.

The synchronization between the \acrshort{mcu} and MATLAB will be handled by MATLAB, which will send commands to the \acrshort{mcu} in the form of control input, to which the \acrshort{mcu} will respond by sending back all the defined data, including the measured angular position and any other relevant signals.
To ensure optimal performance, we will be using a baud rate of $250000$ for the serial communication. The data is stored within a union object containing the structure of the required data and its byte representation on the \acrshort{mcu} side.
Allowing us to send and receive the data in binary format, minimizing the amount of data transmitted over the serial link and reducing latency. The data structure used for sending the data from the \acrshort{mcu} to MATLAB is defined in \coderef{code:data_structure} and more details can be found in \tabref{tab:configurations_of_data_structure}.

\begin{lstlisting}[caption={Data structure used for serial communication between the \acrshort{mcu} and MATLAB.}, label={code:data_structure}, language=C++]
struct __attribute__((packed)) AeroData
{
    unsigned long time;
    float output;
    float control;
    float potentiometer;
    unsigned long control_time;
    unsigned long dt;
};
union AeroDataUnion
{
    AeroData data;
    byte bytes[sizeof(AeroData)];
};
\end{lstlisting}

\begin{center}
    \vspace{-10pt}

    \tabcaption{Communication configurations}
    \label{tab:configurations_of_communication}
    \begin{tabular*}{\textwidth}{@{ \extracolsep{\fill}} lll}
        \toprule
        Configurations & Value/Range & Unit \\
        \midrule
        Baud rate & $250\,000$ & [bps] \\
        Sampling time & $20$ to $100$ & [ms] \\
        Out bytes &  24 & [bytes] \\
        In bytes & 4 & [bytes] \\
        \bottomrule
    \end{tabular*}
\end{center}

\begin{center}
    \vspace{-10pt}
    \tabcaption{Data structure configurations}
    \label{tab:configurations_of_data_structure}
    \begin{tabular*}{\textwidth}{@{ \extracolsep{\fill}} lllll}
        \toprule
        Configurations & Value/Range & Unit & Byte size & Type \\
        \midrule
        time & $0$ to $4\,294\,967\,295$ & [$\mu$s] & 4 & unsigned long \\
        output & $-50$ to $210$ & [\si{\degree}] & 4 & float \\
        control & $0$ to $100$ & [\%] & 4 & float \\
        potentiometer & $0$ to $100$ & [\%] & 4 & float \\
        control\_time & $0$ to $4\,294\,967\,295$ & [$\mu$s] & 4 & unsigned long \\
        dt & $0$ to $4\,294\,967\,295$ & [$\mu$s] & 4 & unsigned long \\
        \bottomrule
        data packet size &  &  & 24 & bytes \\
        \bottomrule
    \end{tabular*}
\end{center}

MATLAB unpacks the received byte array back into the defined structure within a custom class object for easier access to the individual data fields and increased user-friendliness.
While MATLAB sends a single floating point value being the control input to the \acrshort{mcu}.
An example of the communication process can be seen in \figref{fig:communication_process}.


\subsubsection{Communication Timing Measurement} \label{sec:communication_timing_measurement}

The process behind measuring the communication timing was to design an experiment for realizing the measurement.
The proposed experiment involved attaching PicoScope 4000 series high resolution oscilloscope probes to the \acrshort{mcu}'s general-purpose input/output (\acrshort{gpio}) TX and RX pins.

Afterwards, we need to arrange for an ongoing communication between MATLAB and the \acrshort{mcu}, thus we run a simple script in MATLAB to send a constant control input of $20\%$ to the \acrshort{mcu} at a sampling time of $20$ms.
Now we have to capture the start of the communication cycle. Firstly, we have to define what the start of the communication cycle is. Let us define it as the event when MATLAB starts sending the control input to the \acrshort{mcu}.
Thus, to capture this event, we set the oscilloscope to trigger on a rising edge on the RX pin of the \acrshort{mcu}. After setting up the trigger, we can proceed to capture the communication cycle.

We set the oscilloscope to capture a $10$ms time window, which is sufficient to capture the entire communication cycle. We repeat this process $20$ times to ensure accuracy and consistency of the measurement.
The captured data is then analyzed to measure the time taken for the entire communication cycle, from the moment MATLAB sends the control input to the moment the \acrshort{mcu} ends sending the data back to MATLAB.
We measure the time difference between the rising edge on the RX pin and the end of the transmission on the TX pin, which gives us the total time taken for the communication cycle.

Except for monitoring the communication timing, we also observer the order in which the data is sent and received, ensuring that the data integrity is maintained throughout the communication process.
While keeping the planned order of operations intact. Where it starts with MATLAB sending the control input, followed by the \acrshort{mcu} processing the input, reading the sensor data, and finally sending the measured data back to MATLAB.
Without having the order of operations verified, we cannot be certain that whatever control strategy we implement, will function as intended, since the data being used for control computations might be outdated or incorrect.
This entire process is illustrated in \figref{fig:communication_process}.


\begin{center}
    \vbox{%
        \makebox[1\textwidth][c]{%
            \includegraphics[width=0.9\textwidth]{usart_comms.pdf}
        }

        \figcaption{
            Communication process between the \acrshort{mcu} and MATLAB.
        }
        \label{fig:communication_process}
    }%vbox

\end{center}
Where the red colored signal represents the control input from MATLAB and the blue colored signal is for the data sent to MATLAB.

The average time taken for the communication cycle was found to be approximately $3.156$ms.

We have to assume the \acrshort{mcu} might skip a read operation, if the data arrives right after the \acrshort{mcu} attemptes to read it from the RX buffer, thus skipping the entire read-process for that one cycle. Resulting in the brief pause in the communication, before sending the data back to MATLAB.
Or another likewise scenario is when the \acrshort{mcu} read the data, but the time it took to process the measurement, was long enough to result in the blank spot in the communication. This example was measured while using a baud rate of $115\,200$, meaning with baud rate set to $250\,000$ the time taken for the retrieval and transmittion of data is even lower.

\subsubsection{System's schematic diagram}
The schematic diagram of the system is shown in \figref{fig:system_scheme}, where the measurable and controllable signals are illustrated along with the potentiometer signal.
\begin{center}
    \vbox{%
        \makebox[\textwidth][c]{%
            \includegraphics[width=0.9\textwidth]{SystemScheme.pdf}
        }

        \figcaption{
            Schematic diagram of the communication protocol implemented for the \acrshort{as} system.
        }
        \label{fig:system_scheme}
    }%vbox
\end{center}

\subsection{Control Input}
While our system is controlled from MATLAB, the control input is used as the synchronization signal for the entire system. The control input received from MATLAB is further processed on the \acrshort{mcu} side to generate the appropriate \acrshort{pwm} signal for controlling the motor, which in turn controls the pendulum's motion.
The control input signal is defined as a percentage value ranging from $0\%$ to $100\%$, representing the duty cycle of the \acrshort{pwm} signal. Yet, this percentage value is further mapped onto a single byte value ranging from $0$ to $255$, which is the actual value used to set the duty cycle of the \acrshort{pwm} signal on the \acrshort{mcu}.
This mapping is done using a simple linear transformation, where $0\%$ corresponds to a byte value of $0$, and $100\%$ corresponds to a byte value of $255$. The mapping function can be expressed mathematically in the following form
\begin{equation}
    \text{PWM}(u) = \left( \frac{u}{100} \right) \times 255
    \label{eq:pwm_mapping}
\end{equation}
where \( \text{PWM} \) is the byte value used to set the duty cycle of the \acrshort{pwm} signal, and \( u \) is the control input percentage value received from MATLAB. This costs us a small loss in resolution, as we are mapping a continuous range of values onto a discrete set of $256$ possible values.
To be safe the \eqref{eq:pwm_mapping} input is saturated within the range of $0\%$ to $100\%$ before applying the mapping.
Let us define the saturation function as follows
\begin{equation}
    \text{sat}(u, u_{\min}, u_{\max}) =
    \begin{cases}
        u_{\min} & \text{if } u < u_{\min} \\
        u & \text{if } u_{\min} \leq u \leq u_{\max} \\
        u_{\max} & \text{if } u > u_{\max}
    \end{cases}
    \label{eq:saturation_function}
\end{equation}
where \( \text{sat} \) is the saturation function, \( u \) is the input value to be saturated, \( u_{\min} \) is the minimum allowable value, and \( u_{\max} \) is the maximum allowable value. The other approach to defining the saturation function is by using the \texttt{min} and \texttt{max} functions as follows
\begin{equation}
    \text{sat}(u, u_{\min}, u_{\max}) = \min\{\max\{u, u_{\min}\}, u_{\max}\}
    \label{eq:saturation_function_min_max}
\end{equation}
where the variables have the same meaning as in \eqref{eq:saturation_function} and have to obey the following condition \( u,u_{\min},u_{\max} \in \mathbb{R} \) and \( u_{\min} < u_{\max} \).
The $\{\}$ brackets denote the set notation, which is used here to indicate the arguments of the \texttt{min} and \texttt{max} functions, simply said we are choosing minimum and maximum out of a set of values.
Using either of the two definitions of the saturation function will yield the same result.
Yet, it uses different mathematical operations to achieve the same outcome and can be chosen based on personal preference or specific requirements of the implementation.
Or because functions like \texttt{min} and \texttt{max} are often optimized in programming languages and libraries, making them potentially more efficient for certain applications.

Reading the control input from MATLAB in the \acrshort{mcu} is done using the serial communication interface, where the \acrshort{mcu} continuously checks for incoming data on its RX buffer.
When new data is available, more precisly when the number of bytes available in the RX buffer is equal to the size of a single floating point value (4 bytes), the \acrshort{mcu} reads the data from the buffer and stores it in the data structure defined in \coderef{code:data_structure}.
This ensures that the control input is always up-to-date and ready to be used for generating the \acrshort{pwm} signal. The same control input which was read from MATLAB is also sent back to MATLAB as part of the data structure, because it specifically belongs into the very step of the control loop - ensuring no discrepancies arise.

\subsection{Measurable Output}
The measurable output of the system is the angular position of the pendulum, which is measured using a rotary magnetic encoder AS5600. The encoder provides high-resolution angular position feedback via the Inter-Integrated Circuit (\acrshort{i2c}) communication protocol.
Because of the predefined resolution of the encoder, the time it takes to read the angular position is non-negligible, thus we have to account for this delay in our system analysis and controller design.

We can measure this delay experimentally by using the same principle as in the communication timing measurement experiment described in the \secref{sec:communication_timing_measurement}. We set up the oscilloscope to trigger on the rising edge of the control input signal sent from MATLAB to the \acrshort{mcu}.
Then we measure the time difference between this rising edge and the moment when the \acrshort{mcu} starts reading the RX buffer, because we assume that the reading of the angular position only happens after the control input is received, because that is the order of operations we defined earlier.
See \figref{fig:comms_all} for the order operations defined and measured in real-time.

Yet, now we have to attach other probes to monitor the \acrshort{i2c} clock (\acrshort{scl}) and data lines (\acrshort{sda}), to determine the exact moment when the angular position reading starts.
After conducting the experiment, we found that the average time taken for reading the angular position from the encoder is approximately $546.3\mu$s. This measurement can be seen in \figref{fig:encoder_read_timing}.

\begin{center}
    \vbox{%
        \makebox[1\textwidth][c]{%
            \includegraphics[width=0.9\textwidth]{i2c_angle.pdf}
        }

        \figcaption{
            Timing measurement of the angular position reading from the AS5600 encoder.
        }
        \label{fig:encoder_read_timing}
    }%vbox
\end{center}
The green colored signal represents the \acrshort{sda} - which carries the angular position data.

\begin{center}
    \vbox{%
        \makebox[1\textwidth][c]{%
            \includegraphics[width=0.9\textwidth]{usart_comms_all.pdf}
        }

        \figcaption{
            The whole communication cycle timing measurement including the encoder read timing.
        }
        \label{fig:comms_all}
    }%vbox
\end{center}

In the \figref{fig:comms_all} we see the real-time measured order of operations, the red colored signal represents the control input from MATLAB, the green colored signal represents \acrshort{sda} and the blue colored signal is for the data sent to MATLAB respectively. The figure clearly shows the order of operations defined earlier is maintained in real-time.

\subsection{Disturbances} % include frictions

\subsection{Static Characteristic}

\subsection{Dynamic Characteristic}